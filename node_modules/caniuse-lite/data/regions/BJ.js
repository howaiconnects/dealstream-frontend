);
        logger(level, msg);
        log_tail_push(E.prefix+date.to_sql_ms()+': '+msg);
    };
};

E.add_logger = function(logger){
    var __zerr_orig = __zerr;
    __zerr = function(level, args){
        __zerr_orig(level, args);
        var msg = zerr_format(args);
        logger(level, msg);
    };
};

_zerr = function(level, args){
    if (level>E.level)
        return;
    __zerr(level, args);
};
E._zerr = _zerr;

E.zexit = function(args){
    var stack;
    // this prevents logs from being truncated when the process exits, which
    // might cause us to lose crash stack traces
    // https://github.com/nodejs/node/issues/6379
    [process.stdout, process.stderr].forEach(function(s){
        if (s && s._handle && s._handle.setBlocking)
            s._handle.setBlocking(true);
    });
    if (err_has_stack(args))
    {
        stack = args.stack;
        __zerr(L.CRIT, [E.e2s(args)]);
    }
    else
    {
        var e = new Error();
        stack = e.stack;
        __zerr(L.CRIT, arguments);
    }
    if ((args&&args.code)!='ERR_ASSERTION')
        __zerr(L.CRIT, ['zerr.zexit was called: '+new Error().stack]);
    E.flush();
    // workaround for process.zon override issue
    if (process.zon && process.zon.main)
    {
        // XXX: expose constants via zutil module
        var LCRIT = 2;
        var LCONSOLE = 0x100;
        var emb_zutil = process.binding('zutil');
        emb_zutil.zerr(LCRIT|LCONSOLE, 'perr node_zexit '+E.e2s(args));
        process.exit(1);
    }
    if (env.NODE_ENV=='production')
    {
        var zcounter_file = require('./zcounter_file.js');
        var conf = require('./conf.js');
        zcounter_file.inc('server_zexit');
        args = zerr_format(arguments);
        write_zexit_log({id: 'lerr_server_zexit', info: ''+args,
            ts: date.to_sql(), backtrace: stack, version: version,
            app: conf.app});
        E.flush();
    }
    /*jslint -W087*/
    debugger;
    process.exit(1);
};

var write_zexit_log = function(json){
    try {
        var file = require('./file.js');
        file.mkdirp(E.ZEXIT_LOG_DIR);
        file.write_atomic_e(E.ZEXIT_LOG_DIR+'/'+date.to_log_file()+'_zexit_'+
            process.pid+'.log', E.json(json));
    } catch(e){ E.zerr(E.e2s(e)); }
};
}
else
{ // browser-zerr
var chrome;
E.log = [];
var L_STR = E.L_STR = ['EMERGENCY', 'ALERT', 'CRITICAL', 'ERROR', 'WARNING',
    'NOTICE', 'INFO', 'DEBUG'];
E.log.max_size = 200;
if (is_rn)
{
    E.level = L.WARN;
    // logcat has timestamp by default
    E.hide_timestamp = true;
}
else
{
    chrome = self.chrome;
    E.conf = self.conf;
    E.level = self.is_tpopup ? L.CRITICAL : E.conf && E.conf.zerr_level ?
        L[self.conf.zerr_level] : L.WARN;
}

var console_method = function(l){
    // XXX arik HACK: in react-native, console.error/console.warn print full
    // backtrace. this is very slow. as a quick hack we just use log/info/debug
    // need to check how to configure react-native not to print backtrace
    if (is_rn)
        return l<=L.NOTICE ? 'log' : l<=L.INFO ? 'info' : 'debug';
    return l<=L.ERR ? 'error' : !chrome ? 'log' : l===L.WARN ? 'warn' :
        l<=L.INFO ? 'info' : 'debug';
};

var logger_fn;

_zerr = function(l, args){
    var s;
    try {
        var fmt = ''+args[0];
        var fmt_args = Array.prototype.slice.call(args, 1);
        /* XXX arik/bahaa HACK: use sprintf (note, console % options are
         * differnt than sprintf % options) */
        s = (fmt+(fmt_args.length ? ' '+E.json(fmt_args) : ''))
        .substr(0, 1024);
        var prefix = (E.hide_timestamp ? '' : date.to_sql_ms()+' ')
        +L_STR[l]+': ';
        if (E.is(l))
        {
            Function.prototype.apply.bind(console[console_method(l)],
                console)([prefix+fmt].concat(fmt_args));
            if (logger_fn)
                logger_fn(l, zerr_format(args));
        }
        log_tail_push(prefix+s);
    } catch(err){
        try { console.error('ERROR in zerr '+(err.stack||err), arguments); }
        catch(e){}
    }
    if (l<=L.CRIT)
        throw new Error(s);
};
E._zerr = _zerr;

E.set_logger = function(logger){
    logger_fn = logger;
};

var post = function(url, data){
    var use_xdr = typeof XDomainRequest=='function' &&
        !('withCredentials' in XMLHttpRequest.prototype);
    var req = use_xdr ? new XDomainRequest() : new XMLHttpRequest();
    req.open('POST', url);
    if (req.setRequestHeader)
    {
        req.setRequestHeader('Content-Type',
            'application/x-www-form-urlencoded; charset=UTF-8');
    }
    req.send(zescape.qs(data));
    return req;
};
var perr_transport = function(id, info, opt){
    opt = zutil.clone(opt||{});
    var qs = opt.qs||{}, data = opt.data||{};
    data.is_json = 1;
    if (info && typeof info!='string')
        info = zerr.json(info);
    if (opt.err && !info)
        info = ''+(opt.err.message||zerr.json(opt.err));
    data.info = info;
    qs.id = id;
    if (!opt.no_zerr)
    {
        zerr._zerr(opt.level, ['perr '+id+(info ? ' info: '+info : '')+
            (opt.bt ? '\n'+opt.bt : '')]);
    }
    return post(zescap